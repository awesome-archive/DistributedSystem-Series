[toc]

# 复制（Replication）

复制意味着在通过网络连接的多台机器上保留相同数据的副本，我们希望能复制数据，可能出于各种各样的原因：

- 高可用性：即使在一台机器（或多台机器，或整个数据中心）停机的情况下也能保持系统正常运行

- 断开连接的操作：允许应用程序在网络中断时继续工作

- 延迟：将数据放置在距离用户较近的地方，以便用户能够更快地与其交互

- 可扩展性：能够处理比单个机器更高的读取量可以通过对副本进行读取来处理

如果复制中的数据不会随时间而改变，那复制就很简单：将数据复制到每个节点一次就万事大吉。复制的困难之处在于处理复制数据的变更（change），目前三种流行的变更复制算法：单领导者（single leader），多领导者（multi leader）和无领导者（leaderless）。

- 单主复制：客户端将所有写入操作发送到单个节点（领导者），该节点将数据更改事件流发送到其他副本（追随者）。读取可以在任何副本上执行，但从追随者读取可能是陈旧的。

- 多主复制：客户端发送每个写入到几个领导节点之一，其中任何一个都可以接受写入。领导者将数据更改事件流发送给彼此以及任何跟随者节点。

- 无主复制：客户端发送每个写入到几个节点，并从多个节点并行读取，以检测和纠正具有陈旧数据的节点每种方法都有优点和缺点。单主复制是非常流行的，因为它很容易理解，不需要担心冲突解决。在出现故障节点，网络中断和延迟峰值的情况下，多领导者和无领导者复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。

复制可以是同步的，也可以是异步的，在发生故障时对系统行为有深远的影响。尽管在系统运行平稳时异步复制速度很快，但是在复制滞后增加和服务器故障时要弄清楚会发生什么，这一点很重要。如果一个领导者失败了，并且你推动一个异步更新的追随者成为新的领导者，那么最近承诺的数据可能会丢失。我们研究了一些可能由复制滞后引起的奇怪效应，我们讨论了一些有助于决定应用程序在复制滞后时的行为的一致性模型：

- 写后读：用户应该总是看到自己提交的数据。

- 单调读：用户在一个时间点看到数据后，他们不应该在某个早期时间点看到数据。

- 一致前缀读：用户应该将数据视为具有因果意义的状态：例如，按照正确的顺序查看问题及其答复。

## 复制与分区

复制即在几个不同的节点上保存数据的相同副本，可能放在不同的位置。复制提供了冗余：如果一些节点不可用，剩余的节点仍然可以提供数据服务。分区 (Partition/Shard)则是将一个大型数据库拆分成较小的子集，从而不同的分区可以指派给不同的节点（node）。

复制和分区是不同的机制，但它们经常同时使用。

![一个数据库切分为两个分区，每个分区都有两个副本](https://s2.ax1x.com/2020/02/07/12KwQO.md.png)
